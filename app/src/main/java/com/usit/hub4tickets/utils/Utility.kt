package com.usit.hub4tickets.utilsimport android.app.Activityimport android.app.DatePickerDialogimport android.app.ProgressDialogimport android.content.Contextimport android.content.Intentimport android.content.pm.PackageInfoimport android.content.pm.PackageManagerimport android.graphics.*import android.location.Addressimport android.location.Geocoderimport android.net.ConnectivityManagerimport android.net.NetworkInfoimport android.net.Uriimport android.os.Buildimport android.provider.Settingsimport android.support.design.widget.Snackbarimport android.support.v4.content.ContextCompatimport android.support.v4.content.LocalBroadcastManagerimport android.support.v4.os.ConfigurationCompatimport android.text.Spannableimport android.text.Spannedimport android.text.method.LinkMovementMethodimport android.text.style.URLSpanimport android.util.Logimport android.view.Viewimport android.view.WindowManagerimport android.view.inputmethod.InputMethodManagerimport android.widget.RadioButtonimport android.widget.RelativeLayoutimport android.widget.TextViewimport android.widget.Toastimport com.usit.hub4tickets.Rimport com.usit.hub4tickets.utils.view.dialog.CustomDialogPresenterimport com.usit.hub4tickets.utils.webview.LinkSpanToOpenTextLinksimport com.wang.avi.AVLoadingIndicatorViewimport java.io.Fileimport java.io.FileInputStreamimport java.io.FileOutputStreamimport java.net.InetAddressimport java.text.DecimalFormatimport java.text.ParseExceptionimport java.text.SimpleDateFormatimport java.util.*import java.util.regex.Matcherimport java.util.regex.Pattern/** * Created by Bhagyashri Burade * Date: 24/10/2018 * Email: bhagyashri.burade@usit.net.in */object Utility {    private val TAG = Utility::class.java.name    private var sProgressDialog: ProgressDialog? = null    //"yyyy-MM-dd"    val currentDate: String        get() {            val sdfDate = SimpleDateFormat("yyyy-MM-dd")            val now = Date()            return sdfDate.format(now)        }    //"yyyy-MM-dd"    val currentDateTime: String        get() {            val sdfDate = SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z")            val now = Date()            return sdfDate.format(now)        }    fun showProgressDialog(context: Context?) {        if (null != sProgressDialog && sProgressDialog!!.isShowing) {            return        }        sProgressDialog = ProgressDialog(context)        sProgressDialog!!.setMessage(context?.resources?.getString(R.string.loading))        sProgressDialog!!.setCancelable(false)        if (context is Activity) {            if (!context.isFinishing) {                sProgressDialog!!.show()            }        } else {            sProgressDialog!!.show()        }    }    fun showProgress(show: Boolean, circularProgressBar: AVLoadingIndicatorView) {        if (show)            showProgressDialog(circularProgressBar)        else            hideProgressDialog(circularProgressBar)    }    fun showProgressDialog(circularProgressBar: AVLoadingIndicatorView) {        circularProgressBar.visibility = View.VISIBLE        circularProgressBar.show()        // or avi.smoothToShow();    }    fun hideProgressDialog(circularProgressBar: AVLoadingIndicatorView) {        circularProgressBar.visibility = View.GONE        circularProgressBar.hide()    }    fun showNoDataFound(show: Boolean, no_data_found: RelativeLayout) {        if (show)            no_data_found.visibility = View.VISIBLE        else            no_data_found.visibility = View.GONE    }    fun RotateBitmap(source: Bitmap, angle: Float): Bitmap {        val matrix = Matrix()        matrix.postRotate(angle)        return Bitmap.createBitmap(source, 0, 0, source.width, source.height, matrix, true)    }    fun hideProgressBar() {        try {            if (null != sProgressDialog && sProgressDialog!!.isShowing) {                val context = sProgressDialog!!.context                if (context is Activity) {                    if (!context.isFinishing) {                        sProgressDialog!!.dismiss()                        sProgressDialog = null                    }                } else {                    sProgressDialog!!.dismiss()                    sProgressDialog = null                }            }        } catch (e: IllegalArgumentException) {            Log.w(TAG, "Simple ignore the exceprion", e)        }    }    //checks if device connected to internet    fun isConnectedToInternet(context: Context): Boolean {        val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {            val networks = connectivityManager.allNetworks            var networkInfo: NetworkInfo?            for (mNetwork in networks) {                networkInfo = connectivityManager.getNetworkInfo(mNetwork)                if (networkInfo != null && networkInfo.state == NetworkInfo.State.CONNECTED) {                    return true                }            }        } else {            if (connectivityManager != null) {                val info = connectivityManager.allNetworkInfo                if (info != null) {                    for (networkInfo in info) {                        if (networkInfo != null && networkInfo.state == NetworkInfo.State.CONNECTED) {                            /* Log.d(                                 TAG,                                 "NETWORKNAME: " + networkInfo.typeName                             )*/                            return true                        }                    }                }            }        }        Log.v(TAG, "not connected to internet")        return false    }    //show soft keyboard    fun showSoftKeyboard(activity: Activity, view: View) {        val inputMethodManager = activity.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        inputMethodManager.toggleSoftInputFromWindow(            view.applicationWindowToken,            InputMethodManager.SHOW_FORCED, 0        )    }    fun showToastMessage(mContext: Context, msg: String) {        Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show()    }    //Check if email is valid or not    fun validateEmail(strEmail: String): Boolean {        val emailPattern = "[a-zA-Z0-9._-]+@[a-z]+\\.+[a-z]+"        return strEmail.matches(emailPattern.toRegex())    }    //Check if email is valid or not    //val pdwPattern = "^(?=.{6,})(?=.*[@#$%^&+=]).*$"    fun isPasswordValid(password: String): Boolean {        var PASSWORD_PATTERN = "((?=.*\\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%]).{8,20})"        //var PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[0-9])(?=.*[^\\w\\*])[^\\s]{8,20}\$\n"        var pattern: Pattern = Pattern.compile(PASSWORD_PATTERN)        var matcher: Matcher?        matcher = pattern.matcher(password)        return matcher!!.matches()    }    fun setStatusBarColor(mContext: Context, colorCode: String) {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {            val window = (mContext as Activity).window            window.addFlags(WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS)            window.statusBarColor = Color.parseColor("#$colorCode")        }    }    fun isValidEmailAddress(target: CharSequence?): Boolean {        return if (target == null) {            false        } else {            android.util.Patterns.EMAIL_ADDRESS.matcher(target).matches()        }    }    fun applyFont(button: RadioButton, context: Activity) {        button.typeface = Typeface.createFromAsset(context.assets, "fonts/Montserrat-Regular.ttf")    }    fun getAppVersionName(context: Context): String {        var pInfo: PackageInfo? = null        var version = ""        try {            pInfo = context.packageManager.getPackageInfo(context.packageName, 0)            version = pInfo!!.versionName        } catch (e: PackageManager.NameNotFoundException) {            e.printStackTrace()        }        return version    }    fun getDateFormatAsLastSeen(date: Calendar): String {        //   String dayNumberSuffix = getDayNumberSuffix(date.get(Calendar.DAY_OF_MONTH));        val dateFormat = SimpleDateFormat(" d MMM yyyy")        return dateFormat.format(date.time)    }    fun getDateFormatYYYY_MM_DD(dateValue: String): String {        if (dateValue == "" || null == dateValue) {            return ""        }        val calendar = convertStingToDateYYYY_MM_DD(dateValue)        //  String dayNumberSuffix = getDayNumberSuffix(calendar.get(Calendar.DAY_OF_MONTH));        val dateFormat = SimpleDateFormat("yyyy-MM-dd")        return dateFormat.format(calendar.time)    }    private fun convertStingToDateYYYY_MM_DD(dateValue: String): Calendar {        val updatedDateValue =            dateValue.replace("st".toRegex(), "").replace("nd".toRegex(), "").replace("rd".toRegex(), "")                .replace("th".toRegex(), "")        val calendar = GregorianCalendar()        var date: Date? = null        try {            date = SimpleDateFormat("dd MMM yyyy", Locale.ENGLISH).parse(updatedDateValue)            calendar.time = date        } catch (e: ParseException) {            e.printStackTrace()        }        return calendar    }    fun getDateDifferenceInHours(currentDate: Date, lastCachedDate: Date): Long {        val diff = currentDate.time - lastCachedDate.time        val seconds = diff / 1000        val minutes = seconds / 60        return minutes / 60    }    fun getDateFormatAsLastSeen(context: Context, smsTimeInMilis: String): String {        val smsTime = Calendar.getInstance()        val sdf = SimpleDateFormat("yyyy-mm-dd HH:mm:ss", Locale.ENGLISH)        try {            smsTime.time = sdf.parse(smsTimeInMilis)// all done        } catch (e: ParseException) {            e.printStackTrace()        }        val now = Calendar.getInstance()        return if (now.get(Calendar.DATE) == smsTime.get(Calendar.DATE)) {            "Today "        } else if (now.get(Calendar.DATE) - smsTime.get(Calendar.DATE) == 1) {            "Yesterday "        } else {            Utility.getDateFormat(smsTimeInMilis)        }    }    /*          Convert date string(1991-11-23) to  format like 2nd Sept 2016          param : String           */    fun getDateFormat(dateValue: String?): String {        if (null == dateValue) {            return ""        } else if (dateValue == "") {            return ""        }        val calendar = convertStingToDate(dateValue)        // String dayNumberSuffix = getDayNumberSuffix(calendar.get(Calendar.DAY_OF_MONTH));        val dateFormat = SimpleDateFormat("dd MMM yyyy")        return dateFormat.format(calendar?.time)    }    fun convertStingToDate(dateValue: String): Date? {        val calendar = GregorianCalendar()        var date: Date? = null        try {            date = SimpleDateFormat("dd/mm/yyyy", Locale.ENGLISH).parse(dateValue)        } catch (e: ParseException) {            e.printStackTrace()        }        // calendar.time = date        return date    }    fun getResizedBitmap(image: Bitmap, maxSize: Int): Bitmap {        var width = image.width        var height = image.height        val bitmapRatio = width.toFloat() / height.toFloat()        if (bitmapRatio > 0) {            width = maxSize            height = (width / bitmapRatio).toInt()        } else {            height = maxSize            width = (height * bitmapRatio).toInt()        }        return Bitmap.createScaledBitmap(image, width, height, true)    }    fun reduceSizeOfImage(file: File): File? {        try {            // BitmapFactory options to downsize the image            val o = BitmapFactory.Options()            o.inJustDecodeBounds = true            o.inSampleSize = 6            // factor of downsizing the image            var inputStream = FileInputStream(file)            //Bitmap selectedBitmap = null;            BitmapFactory.decodeStream(inputStream, null, o)            inputStream.close()            // The new size we want to scale to            val REQUIRED_SIZE = 25            // Find the correct scale value. It should be the power of 2.            var scale = 1            while (o.outWidth / scale / 2 >= REQUIRED_SIZE && o.outHeight / scale / 2 >= REQUIRED_SIZE) {                scale *= 2            }            val o2 = BitmapFactory.Options()            o2.inSampleSize = scale            inputStream = FileInputStream(file)            val selectedBitmap = BitmapFactory.decodeStream(inputStream, null, o2)            inputStream.close()            // here i override the original image file            file.createNewFile()            val outputStream = FileOutputStream(file)            selectedBitmap!!.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)            return file        } catch (e: Exception) {            return null        }    }    fun getDeviceInfo(context: Context): String {        var pInfo: PackageInfo? = null        var version = 1        try {            pInfo = context.packageManager.getPackageInfo(context.packageName, 0)            version = pInfo!!.versionCode        } catch (e: PackageManager.NameNotFoundException) {            e.printStackTrace()        }        /*        Get Device Info         */        var deviceInformation = ""        deviceInformation += "\n OS Version: " + System.getProperty("os.version") + "(" + android.os.Build.VERSION.INCREMENTAL + ")"        deviceInformation += "\n OS API Level: " + android.os.Build.VERSION.SDK_INT        deviceInformation += "\n Device: " + android.os.Build.DEVICE        deviceInformation += "\n Model (and Product): " + android.os.Build.MODEL + " (" + android.os.Build.PRODUCT + ")"        deviceInformation += "\n AppVersion: $version"        deviceInformation += "\n FCM Token " + Pref.getValue(context, PrefConstants.DEVICE_TOKEN, "")        //Log.d("Device_info", "" + version)        return deviceInformation    }    fun getStringTypeFromServerDate(dateValue: Date?): String {        if (null == dateValue || dateValue.equals("")) {            return ""        }        var date = ""        try {            date = SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.ENGLISH).format(dateValue)        } catch (e: Exception) {            e.printStackTrace()        }        return date    }    fun setTextColor(textView: TextView, colorCode: String) {        textView.setTextColor(Color.parseColor("#$colorCode"))    }    fun formatCustomerRange(customerPoints: String): String {        return if (customerPoints != "") {            if (java.lang.Double.parseDouble(customerPoints) > 9999999) {                "\u221E"            } else DecimalFormat("##.##").format(java.lang.Double.parseDouble(customerPoints))        } else ""    }    fun getMobileNumberFormat(mobileNumber: String): String {        if (mobileNumber == "") {            return ""        }        val splitStr = mobileNumber.split("\\s+".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()        return splitStr[1]    }    fun getDateFormatYYYY_MM_DDFromServerDate(dateValue: String): Date? {        if (dateValue == "" || null == dateValue) {            return null        }        var date: Date? = null        try {            date = SimpleDateFormat("yyyy-MM-dd hh:mm:ss", Locale.ENGLISH).parse(dateValue)        } catch (e: Exception) {            e.printStackTrace()        }        var resultDate: Date? = null        try {            resultDate =                SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH).parse(SimpleDateFormat("yyyy-MM-dd").format(date))        } catch (e: ParseException) {            e.printStackTrace()        }        return resultDate    }    fun dateBetween(startDate: Date?, endDate: Date?): Boolean {        // assume these are set to something        if (null == startDate || endDate == null) {            return false        }        val date = convertInToDate_yyyyMMdd(currentDate)        // the date in question        // DateUtils.isToday(startDate);        if (date == startDate) {            return true        } else if (date == endDate) {            return true        }        return date!!.after(startDate) && date.before(endDate)    }    fun convertInToDate_yyyyMMdd(dateValue: String?): Date? {        if (null == dateValue) {            return null        }        var date: Date? = null        try {            date = SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH).parse(dateValue)        } catch (e: Exception) {            e.printStackTrace()        }        /*Date resultDate = null;        try {            resultDate = new SimpleDateFormat("yyyy-MM-dd", Locale.ENGLISH).parse(new SimpleDateFormat("yyyy-MM-dd").format(date));        } catch (ParseException e) {            e.printStackTrace();        }*/        return date    }    fun rateUsDialog(context: Context, activity: Activity, merchantId: String) {        CustomDialogPresenter.showDialog(            context,            "Show us some love!",            "If you enjoy using smat loyal, please take a moment to rate it and leave  us your valuable feedback.",            "Rate now",            "I'll do it later",            object : CustomDialogPresenter.CustomDialogView {                override fun onPositiveButtonClicked() {                    Pref.setValue(context, Constant.Path.IS_RATE_US, true)                    val appPackageName = context.packageName                    try {                        context.startActivity(                            Intent(                                Intent.ACTION_VIEW, Uri                                    .parse("market://details?id=$appPackageName")                            )                        )                    } catch (anfe: android.content.ActivityNotFoundException) {                        context.startActivity(                            Intent(                                Intent.ACTION_VIEW,                                Uri.parse("https://play.google.com/store/apps/details?id=$appPackageName")                            )                        )                    }                }                override fun onNegativeButtonClicked() {                    Pref.setValue(context, Constant.Path.IS_RATE_US, false)                }            })    }    fun getDateDeference(smsTimeInMilis: String): Boolean {        var createdTimeDate: Date? = null        try {            createdTimeDate = SimpleDateFormat("yyyy-MM-dd HH:mm:ss").parse(smsTimeInMilis)        } catch (e: Exception) {            e.printStackTrace()        }        val now = Calendar.getInstance()        now.add(Calendar.DAY_OF_YEAR, -16)        val daysAgo = now.time        return if (createdTimeDate == daysAgo) {            false        } else daysAgo.after(createdTimeDate)    }    fun dateAfterCurrentDate(expiryDate: Date?): Boolean {        if (null == expiryDate) {            return false        }        // assume these are set to something        val date = convertInToDate_yyyyMMdd(currentDate)        // the date in question 2017-03-31        return if (date == expiryDate) {            true        } else date!!.before(expiryDate)    }    fun convertDpToPixel(dp: Float, context: Context): Int {        val resources = context.resources        return (dp * resources.displayMetrics.density).toInt()    }    fun openUrlInWebView(mContext: Context, spannable: Spannable, textView: TextView, header: String) {        val spans = spannable.getSpans(0, spannable.length, URLSpan::class.java)        for (urlSpan in spans) {            val linkSpan = LinkSpanToOpenTextLinks(mContext, urlSpan.url, header)            val spanStart = spannable.getSpanStart(urlSpan)            val spanEnd = spannable.getSpanEnd(urlSpan)            spannable.setSpan(linkSpan, spanStart, spanEnd, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE)            spannable.removeSpan(urlSpan)        }        textView.movementMethod = LinkMovementMethod.getInstance()        textView.setText(spannable, TextView.BufferType.SPANNABLE)    }    fun getDeviceId(context: Context?): String {        val deviceId: String = Settings.Secure.getString(            context?.contentResolver,            Settings.Secure.ANDROID_ID        )        return deviceId    }    fun dateDialog(        c: Calendar?,        activity: Activity?,        textView: TextView    ) {        val dateFormatter = SimpleDateFormat("dd/MM/yyyy", Locale.US)        var day = c!!.get(Calendar.DAY_OF_MONTH)        var year = c.get(Calendar.YEAR)        var month = c.get(Calendar.MONTH)        val listener = DatePickerDialog.OnDateSetListener { _, year, monthOfYear, dayOfMonth ->            val newDate = Calendar.getInstance()            newDate.set(year, monthOfYear, dayOfMonth)            textView.text = dateFormatter.format(newDate.time)        }        val dpDialog = DatePickerDialog(activity!!, listener, year, month, day)        dpDialog.show()    }    fun dateDialogWithMinMaxDate(        c: Calendar?,        activity: Activity?,        textView: TextView,        minDateNumber: Int    ) {        val readFormat = SimpleDateFormat("EEE MMM dd yyyy hh:mm aaa", Locale.ENGLISH)        val writeFormat = SimpleDateFormat("dd/MM/yyyy", Locale.ENGLISH)        var day = c!!.get(Calendar.DAY_OF_MONTH)        var year = c.get(Calendar.YEAR)        var month = c.get(Calendar.MONTH)        val listener = DatePickerDialog.OnDateSetListener { _, year, monthOfYear, dayOfMonth ->            val newDate = Calendar.getInstance()            newDate.set(year, monthOfYear, dayOfMonth)            textView.text = writeFormat.format(newDate.time)        }        val dpDialog = DatePickerDialog(activity!!, listener, year, month, day)        val minDate = Calendar.getInstance()        val minTimeMillis = System.currentTimeMillis()        minDate.timeInMillis = minTimeMillis        minDate.set(Calendar.HOUR_OF_DAY, minDate.getMinimum(Calendar.HOUR_OF_DAY))        minDate.set(Calendar.MINUTE, minDate.getMinimum(Calendar.MINUTE))        minDate.set(Calendar.SECOND, minDate.getMinimum(Calendar.SECOND))        minDate.set(Calendar.MILLISECOND, minDate.getMinimum(Calendar.MILLISECOND))        minDate.add(Calendar.DAY_OF_YEAR, minDateNumber)        dpDialog.datePicker.minDate = minDate.timeInMillis        val maxDate = Calendar.getInstance()        maxDate.add(Calendar.YEAR, 1)        dpDialog.datePicker.maxDate = maxDate.timeInMillis        dpDialog.show()    }    fun dateDialogWithMinMaxDateMulticity(        c: Calendar?,        activity: Activity?,        textView: TextView,        minDateNumber: Int,        listener: DatePickerDialog.OnDateSetListener?    ) {        val readFormat = SimpleDateFormat("EEE MMM dd yyyy hh:mm aaa", Locale.ENGLISH)        var day = c!!.get(Calendar.DAY_OF_MONTH)        var year = c.get(Calendar.YEAR)        var month = c.get(Calendar.MONTH)        val dpDialog = DatePickerDialog(activity!!, listener, year, month, day)        val minDate = Calendar.getInstance()        val minTimeMillis = System.currentTimeMillis()        minDate.timeInMillis = minTimeMillis        minDate.set(Calendar.HOUR_OF_DAY, minDate.getMinimum(Calendar.HOUR_OF_DAY))        minDate.set(Calendar.MINUTE, minDate.getMinimum(Calendar.MINUTE))        minDate.set(Calendar.SECOND, minDate.getMinimum(Calendar.SECOND))        minDate.set(Calendar.MILLISECOND, minDate.getMinimum(Calendar.MILLISECOND))        minDate.add(Calendar.DAY_OF_YEAR, minDateNumber)        dpDialog.datePicker.minDate = minDate.timeInMillis        val maxDate = Calendar.getInstance()        maxDate.add(Calendar.YEAR, 1)        dpDialog.datePicker.maxDate = maxDate.timeInMillis        dpDialog.show()    }    fun hideKeyBordActivity(activity: Activity) {        if (activity.currentFocus != null) {            val inputMethodManager = activity.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager            inputMethodManager.hideSoftInputFromWindow(activity.currentFocus!!.windowToken, 0)        }    }    fun View.hideKeyboard() {        val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        imm.hideSoftInputFromWindow(windowToken, 0)    }    fun showDialog(title: String?, message: String?, context: Context?, activity: Activity?) {        if (message != null) {            showToast(message, context, activity)        } else {            showToast(context?.getString(R.string.message_failed_request_general), context, activity)        }    }    private fun showToast(message: String?, context: Context?, activity: Activity?) {        val snackbar = message?.let {            Snackbar.make(                activity!!.findViewById(android.R.id.content),                it, Snackbar.LENGTH_SHORT            )        }        val sbView = snackbar?.view        val textView = sbView?.findViewById<View>(android.support.design.R.id.snackbar_text) as TextView        textView.setTextColor(ContextCompat.getColor(context!!, R.color.white))        snackbar.show()    }    fun hideSoftKeyboard(view: View) {        var imm = view.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager        imm.hideSoftInputFromWindow(view.windowToken, InputMethodManager.HIDE_IMPLICIT_ONLY)    }    fun showCustomDialog(        mContext: Context?,        message: String?,        title: String?,        listner: CustomDialogPresenter.CustomDialogView?    ) {        CustomDialogPresenter.showDialog(            mContext,            title,            message,            mContext?.resources?.getString(                R.string.ok            )!!,            null, listner        )    }    fun showProgress(show: Boolean, context: Context?) {        if (show)            showProgressDialog(context = context)        else            hideProgressBar()    }    fun getCurrentDateNow(): String {        var c = Calendar.getInstance().time        val df = SimpleDateFormat("dd/MM/yyyy", Locale.US)        return df.format(c)    }    fun getCurrentDateAfter(): String {        var calendar = Calendar.getInstance()        val df = SimpleDateFormat("dd/MM/yyyy", Locale.US)        calendar.time = Calendar.getInstance().time        calendar.add(Calendar.DAY_OF_MONTH, 1)        var newDate = calendar.time        return df.format(newDate)    }    fun getCurrentDatePlus3(): String {        var calendar = Calendar.getInstance()        val df = SimpleDateFormat("dd/MM/yyyy", Locale.US)        calendar.time = Calendar.getInstance().time        calendar.add(Calendar.DATE, 3)        var newDate = calendar.time        return df.format(newDate)    }    fun getAddress(context: Context, LATITUDE: Double, LONGITUDE: Double): String {        //Set Address        try {            val geocoder = Geocoder(context, Locale.getDefault())            val addresses: List<Address> = geocoder.getFromLocation(LATITUDE, LONGITUDE, 1)            var countryName: String? = null            var language: String? = null            if (addresses.isNotEmpty()) {                var address = addresses[0]                    .getAddressLine(0)               // var city = addresses[0].locality               // var state = addresses[0].adminArea                var countryName = addresses[0].countryName                var countryCode = addresses[0].countryCode               // var postalCode = addresses[0].postalCode                language = addresses[0].locale.language // Only if available else return NULL                var currency: String? = ""                if (countryCode.equals("IN"))                    currency = "INR"                else                    currency = Currency.getInstance(Utility.getCurrentLocale(context)).currencyCode                Pref.setValue(                    context,                    PrefConstants.CURRENCY_DEFAULT, currency!!                )                Pref.setValue(                    context,                    PrefConstants.DEFAULT_LOCATION, countryName!!                )                Pref.setValue(                    context,                    PrefConstants.DEFAULT_LANGUAGE, language                )                if (!Pref.getValue(                        context,                        PrefConstants.IS_FIRST_TIME_ALLOW,                        false                    )                ) {                    var filter = "thisIsForMyFragment"                    val intent = Intent(filter)                    LocalBroadcastManager.getInstance(context).sendBroadcast(intent)                }                /* Log.d(TAG, "getAddress:" + address)                 Log.d(TAG, "city:" + city)                 Log.d(TAG, "countryCode:" + countryCode)                 Log.d(TAG, "postalCode:" + postalCode)                 Log.d(TAG, "language:" + language)                 Log.d(TAG, "language:" + language)                 Log.d(TAG, "currency:" + currency)           */            }            Log.e("loc addrs", countryName + " " + language)            return countryName + " / " + language        } catch (e: Exception) {            e.printStackTrace()        }        return "" + "/" + ""    }    fun getCurrentLocale(context: Context): Locale {        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {            return ConfigurationCompat.getLocales(context.resources.configuration)[0]        } else {            //noinspection deprecation            return context.resources.configuration.locale        }    }    fun onMinusClick(        textView: TextView,        adults: Boolean,        infants: Boolean,        infantsTextView: TextView?    ) {        if (adults) {            if (Integer.parseInt(textView.text.toString()) != 0 && Integer.parseInt(textView.text.toString()) in 1..7) {                if (Integer.parseInt(textView.text.toString()) in 2..7) {                    textView.text = Integer.parseInt(textView.text.toString()).minus(1).toString()                } else                    textView.text = "1"                if (infantsTextView?.text!! != "0") {                    if (Integer.parseInt(textView.text.toString()) in 1..3) {                        when (textView.text.toString().toInt()) {                            1 -> infantsTextView.text = "1"                            2 -> infantsTextView.text = "2"                            3 -> infantsTextView.text = "3"                        }                    }                }            } else {                textView.text = "1"            }        } else if (infants) {            if (Integer.parseInt(textView.text.toString()) in 1..3) {                textView.text = Integer.parseInt(textView.text.toString()).minus(1).toString()            } else                textView.text = "0"        } else {            if (Integer.parseInt(textView.text.toString()) in 1..7)                textView.text = Integer.parseInt(textView.text.toString()).minus(1).toString()            else                textView.text = "0"        }    }    fun onAddClick(        textView: TextView,        adults: Boolean,        infants: Boolean,        adultsStr: String?    ) {        if (adults) {            if (Integer.parseInt(textView.text.toString()) != 0 && Integer.parseInt(textView.text.toString()) in 1..7) {                if (Integer.parseInt(textView.text.toString()) in 1..7)                    textView.text = Integer.parseInt(textView.text.toString()).plus(1).toString()                else                    textView.text = "1"            } else {                textView.text = "1"            }        } else if (infants) {            if (Integer.parseInt(textView.text.toString()) in 0..3) {                if (Integer.parseInt(textView.text.toString()) in 0..adultsStr!!.toInt().minus(1))                    textView.text = Integer.parseInt(textView.text.toString()).plus(1).toString()            } else                textView.text = "0"        } else {            if (Integer.parseInt(textView.text.toString()) in 0..7)                textView.text = Integer.parseInt(textView.text.toString()).plus(1).toString()            else                textView.text = "0"        }    }    fun isEmailValid(email: String): Boolean {        return try {            val EMAIL_STRING =                "^[_A-Za-z0-9-\\+]+(\\.[_A-Za-z0-9-]+)*@" + "[A-Za-z0-9-]+(\\.[A-Za-z0-9]+)*(\\.[A-Za-z]{2,})$"            val pattern = Pattern.compile(EMAIL_STRING)            val matcher = pattern.matcher(email)            matcher.matches()        } catch (e: Exception) {            e.printStackTrace()            false        }    }    fun validateDate(dateValue: String, returnDate: String): Boolean {        val calendar = GregorianCalendar()        val calendarReturn = GregorianCalendar()        var date: Date? = null        var dateReturn: Date? = null        try {            date = SimpleDateFormat("dd/MM/yyyy", Locale.ENGLISH).parse(dateValue)            dateReturn = SimpleDateFormat("dd/MM/yyyy", Locale.ENGLISH).parse(returnDate)        } catch (e: ParseException) {            e.printStackTrace()        }        calendar.time = date        calendarReturn.time = dateReturn        if (calendarReturn.time!!.equals(calendar.time))            return true        else return calendarReturn.time!!.after(calendar.time)    }    fun getDurationFromString(        totalDuration: String?    ): Int {        if (totalDuration != null) {            val time = totalDuration //mm:ss            val units =                time.split(":".toRegex()).dropLastWhile { it.isEmpty() }                    .toTypedArray() //will break the string up into an array            val minutes = Integer.parseInt(units[0]) //first element            val seconds = Integer.parseInt(units[1]) //second element            val duration = 60 * minutes + seconds //add up our values            return duration        } else            return 0    }    fun isInternetAvailable(): Boolean {        try {            val ipAddr = InetAddress.getByName("google.com")            //You can replace it with your name            return !ipAddr.equals("")        } catch (e: Exception) {            return false        }    }    fun showPassengersAdult(adults: String?): CharSequence? {        return if (!adults.equals("0"))            "$adults Adult "        else            ""    }    fun showPassengersChildren(children: String?): CharSequence? {        return if (!children.equals("0"))            "$children Children "        else            ""    }    fun showPassengersInfants(infants: String?): CharSequence? {        return if (!infants.equals("0"))            "$infants Infants "        else            ""    }}